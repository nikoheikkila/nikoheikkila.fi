---
lang: en
author: Niko Heikkilä
date: 2019-07-15
cover: cover.png
title: The Definitive List of Things I Don't Know
type: post
excerpt: We have a serious problem and we as professionals are responsible for fixing it by admitting the world that you don't need to know everything.
categories:
  - Lists
  - Programming
  - Career
  - Beginners
---

Lately, I've been pondering about my work and where I want to head with it. Thus, it's only logical to understand what I need to learn to get there. Turns out, the more I think of things I don't know the more assured I grow about the importance of admitting those instead of hiding them.

A large part of the tech industry suffers from a misconception of needing to be a supreme developer who knows everything and can't burn out. For years, we've seen job ads ridiculously detached from the real world. These ads require candidates to have more than 5 years of expertise with more than 10 different techniques.

Product and business owners demand more throughput with fewer resources. Recruiters fail to hire the right people when they don't interview the existing developers about the skills needed in their daily work. Venture capitalists build and live in their own imaginary worlds filled with engineers that can mine raw diamonds every day while working 60-80 hours a week.

Us developers are not innocent either. Without a hint of criticism, we tend to share these massive learning roadmaps about skills we need to master before being entitled to some rank.

Don't even ask where all the impostor syndromes are coming from.

Meanwhile, we should be supporting demographical minorities to start their careers in tech. For some of the major tech companies, it's enough to change your profile pictures on social media to include a cool rainbow and everything is given. You are welcome to be a member of our toxic work culture as long as you fill this list of 20 unrealistic conditions imposed on you.

We have a serious problem and we as professionals are responsible for fixing it by admitting the world that you don't need to know everything.

This post was sparked into life by [a similar list](https://overreacted.io/things-i-dont-know-as-of-2018/) from **Dan Abramov** and the far-spread dumpster fire on Twitter about so-called ["10x engineers"](https://twitter.com/skirani/status/1149302828420067328).

The aim of this post is not to give a bad picture of myself. You can find out plenty of the things I'm good at by following my blog and social media accounts or talking to me. Nevertheless, let's keep it out of the scope of this post.

Without further introduction here we go. I will likely revise this list at a later date.

## The Definitive List of Things I Don't Know (2019)

- **Remembering programming language syntax, algorithms, module usage**, and many other things without looking up Internet cheat sheets. Do you think I'm a supercomputer with infinite storage and processing capacity?
- **Remembering what I worked on more than a week ago** which is especially troublesome when the code you wrote is pushed to production three weeks later for you to support. Did I really write this? Oh, according to version control I did. Well, let's see…
- **Avoiding bugs.** We all create them, no need to stress about it. At least I can squash the defects I've given birth to.
- **Naming variables, functions, classes**, and other concrete parts of the application. Often I can give them their proper and final names only after seeing how the application as a whole works best. Until that point, enjoy reading my generic signatures such as `def get_item_from_store(n: str) -> Item`.
- **Updating documentation as I code.** The software documentation by definition is always outdated, anyway, so this is not a big issue.
- **Doing *Test-Driven Development* (TDD).** On many occasions, I have to play around with my vision and write some boilerplate code before being able to figure out what kind of tests I need. Many of the assumptions with TDD indicate you instantly know all the test cases by looking at the acceptance criteria which is very dangerous. Wrong or badly implemented tests are always worse than no tests at all.
- Writing code using an incredible repertoire of *Vim* macros and **achieving a glorious 100 lines of code per second typing speed.** I've configured my editor with the most important shortcuts but I still need to reach for the mouse to move a cursor to its right place from time to time.
- **Estimating the time required for a feature to be completed.** 1-2 weeks at most with the current velocity if there are no surprises with 3rd party dependencies is my standard guess. Wait a second and I'll roll you some story points with my *D&D* dice set. Bring your best deck to the meeting.
- **Creating beautiful UIs.** I can center a couple of elements with CSS using `margin` rules and pick a satisfying font pair from *Google Fonts*. Anything beyond that like complex frontend frameworks, grid systems, and flexboxes beat me. I'm slowly getting to cope with *React*, though.
- **Writing low-level code.** Especially when it's targeted for embedded systems. I took a couple of C/C++ courses during my studies but I've happily forgotten most of it after steering my career path to web development. Sure, I can create a fancy marquee text on a LED display by programming I/O signals but I'll probably forget to free all the memory and your device will crash or set ablaze.
- **Mobile platforms.** I once tried to create something on Android but noticed that I don't know the dark magic of Java IDEs and gave up. I've heard you can replace Java with some other language now but I still would write a PWA with web technologies instead.
- **Game development.** I've studied game design and written about games but I don't know how to actually develop them. The most advanced thing I've accomplished is a *Pong* (1972) clone following a tutorial.
- **Graphical design.** I've learned some design tools (*Sketch, Lunacy, Invision*) while searching a way to quickly do cover images for this blog. So I know how to place shadowed text on a background with some additional clipart. Don't hire me to do advertising material for your next campaign, though.
- **Being an IT support.** The messy world of drivers, peripherals, consumer operating systems, and different network stacks is so large that I'm constantly being overwhelmed. If you call me to fix your printer or home router, I can only ask you to turn it off and on again. By chance I might establish a remote desktop connection to reinstall whatever drivers are available.
- **Hardware.** Related to the above, the most advanced thing I've done to my PC is to switch new HDD and SSD drives inside it which took a couple of hours wrenching and swearing. My next computer is definitely a laptop.
- …and many more things I haven't yet thought about.

None of us engineers are "supreme developers", "rockstar coders", or "agile ninjas". Not even in the wildest dreams of these half-witted VCs. If your HR department thinks that it's an essential part of the job to survive without looking things up on the Internet, kindly pass my name from the list of heads to hunt, please. I'm not good at all the things and it's fine.

But the one thing I'm exceptionally good at? Admitting when I don't know something and asking for help. I hope you are like me.
